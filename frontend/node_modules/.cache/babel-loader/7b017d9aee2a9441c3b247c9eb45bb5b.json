{"ast":null,"code":"import { transformToViewState, applyViewStateToTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nconst handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nexport default class Mapbox {\n  constructor(MapClass, props, container) {\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = e => {\n      // @ts-ignore\n      const cb = this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = e => {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        this._updateHover(e);\n      } // @ts-ignore\n\n\n      const cb = this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          const features = this._hoveredFeatures || this._map.queryRenderedFeatures(e.point, {\n            layers: this.props.interactiveLayerIds\n          });\n\n          if (!features.length) {\n            return;\n          }\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = e => {\n      if (!this._internalUpdate) {\n        // @ts-ignore\n        const cb = this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in this._deferredEvents) {\n        this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  get map() {\n    return this._map;\n  }\n\n  get transform() {\n    return this._renderTransform;\n  }\n\n  setProps(props) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n\n    if (settingsChanged) {\n      this._renderTransform = this._map.transform.clone();\n    }\n\n    const sizeChanged = this._updateSize(props);\n\n    const viewStateChanged = this._updateViewState(props, true);\n\n    this._updateStyle(props, oldProps);\n\n    this._updateStyleComponents(props, oldProps);\n\n    this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n\n\n    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props, container) {\n    const that = Mapbox.savedMaps.pop();\n\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step1: reparenting child nodes from old container to new container\n\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    } // Step2: replace the internal container with new container from the react component\n    // @ts-ignore\n\n\n    map._container = container; // Step 3: apply new props\n\n    if (props.initialViewState) {\n      that._updateViewState(props.initialViewState, false);\n    }\n\n    map.resize();\n    that.setProps({ ...props,\n      styleDiffing: false\n    }); // Simulate load event\n\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    return that;\n  }\n  /* eslint-disable complexity,max-statements */\n\n\n  _initialize(container) {\n    const {\n      props\n    } = this;\n    const mapOptions = { ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(props.mapStyle)\n    };\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n\n    this._renderTransform = map.transform.clone(); // Hack\n    // Insert code into map's render cycle\n\n    const renderMap = map._render;\n\n    map._render = arg => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n\n    map._renderTaskQueue.run = arg => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n      this._onBeforeRepaint();\n    };\n\n    map.on('render', () => this._onAfterRepaint()); // Insert code into map's event pipeline\n\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n\n  recycle() {\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n\n\n  redraw() {\n    const map = this._map; // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n\n        map._frame = null;\n      } // the order is important - render() may schedule another update\n\n\n      map._render();\n    }\n  }\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n\n\n  _updateSize(nextProps) {\n    // Check if size is controlled\n    const {\n      viewState\n    } = nextProps;\n\n    if (viewState) {\n      const map = this._map;\n\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n\n    return false;\n  } // Adapted from map.jumpTo\n\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateViewState(nextProps, triggerEvents) {\n    if (this._internalUpdate) {\n      return false;\n    }\n\n    const map = this._map;\n    const tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n    const {\n      zoom,\n      pitch,\n      bearing\n    } = tr;\n    const changed = applyViewStateToTransform(tr, { ...transformToViewState(map.transform),\n      ...nextProps\n    });\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n      deferredEvents.move = true;\n      deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n      deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n      deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n    } // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n\n\n    if (!map.isMoving()) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateSettings(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n      }\n    }\n\n    return changed;\n  }\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n\n\n  _updateStyle(nextProps, currProps) {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const options = {\n        diff: nextProps.styleDiffing\n      };\n\n      if ('localIdeographFontFamily' in nextProps) {\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n\n      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n      return true;\n    }\n\n    return false;\n  }\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateStyleComponents(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    if (map.style.loaded()) {\n      if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n\n      if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n\n      if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain); // Copy changes to the transform\n          // @ts-ignore\n\n          this._renderTransform.elevation = map.transform.elevation;\n        }\n      }\n    }\n\n    return changed;\n  }\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n\n\n  _updateHandlers(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName];\n\n      if (!deepEqual(newValue, currProps[propName])) {\n        changed = true;\n\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n\n    return changed;\n  }\n\n  _updateHover(e) {\n    const {\n      props\n    } = this;\n    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      let features;\n\n      if (eventType === 'mousemove') {\n        try {\n          features = this._map.queryRenderedFeatures(e.point, {\n            layers: props.interactiveLayerIds\n          });\n        } catch {\n          features = [];\n        }\n      } else {\n        features = [];\n      }\n\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n\n        this._onPointerEvent(e);\n      }\n\n      this._hoveredFeatures = features;\n\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n\n        this._onPointerEvent(e);\n      }\n\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _fireEvent(baseFire, event, properties) {\n    const map = this._map;\n    const tr = map.transform;\n    const eventType = typeof event === 'string' ? event : event.type;\n\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        event.viewState = transformToViewState(tr);\n      }\n\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n        return map;\n      }\n    }\n\n    baseFire.call(map, event, properties);\n    return map;\n  } // All camera manipulations are complete, ready to repaint\n\n\n  _onBeforeRepaint() {\n    const map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n    this._internalUpdate = true;\n\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n\n    this._internalUpdate = false;\n    const tr = this._map.transform; // Make sure camera matches the current props\n\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  let accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch {// ignore\n  }\n\n  return accessToken;\n}","map":{"version":3,"sources":["/Users/genie/code/chiutzuning/find-museum-app/frontend/node_modules/react-map-gl/dist/esm/mapbox/mapbox.js"],"names":["transformToViewState","applyViewStateToTransform","normalizeStyle","deepEqual","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoom","zoomend","rotatestart","rotate","rotateend","pitchstart","pitch","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Mapbox","constructor","MapClass","props","container","_map","_internalUpdate","_inRender","_hoveredFeatures","_deferredEvents","_onEvent","e","cb","type","_onPointerEvent","_updateHover","interactiveLayerIds","features","queryRenderedFeatures","point","layers","length","_onCameraEvent","_MapClass","_initialize","map","transform","_renderTransform","setProps","oldProps","settingsChanged","_updateSettings","clone","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","reuse","that","savedMaps","pop","oldContainer","getContainer","className","childNodes","appendChild","_container","initialViewState","styleDiffing","isStyleLoaded","fire","once","mapOptions","accessToken","mapboxAccessToken","getAccessTokenFromEnv","style","mapStyle","viewState","Object","assign","center","longitude","latitude","bearing","gl","getContext","HTMLCanvasElement","prototype","padding","setPadding","cursor","getCanvas","renderMap","_render","arg","call","runRenderTaskQueue","_renderTaskQueue","run","_onBeforeRepaint","on","_onAfterRepaint","fireEvent","_fireEvent","bind","width","height","eventName","recycle","push","destroy","_frame","cancel","nextProps","triggerEvents","tr","changed","deferredEvents","currProps","propName","toUpperCase","slice","options","diff","localIdeographFontFamily","setStyle","loaded","light","setLight","fog","setFog","terrain","getSource","source","setTerrain","elevation","newValue","enable","disable","shouldTrackHoveredFeatures","onMouseMove","onMouseEnter","onMouseLeave","eventType","wasHovering","isHovering","baseFire","event","properties","location","match","exec","search","process","env","MapboxAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN"],"mappings":"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","sourcesContent":["import { transformToViewState, applyViewStateToTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst pointerEvents = {\n    mousedown: 'onMouseDown',\n    mouseup: 'onMouseUp',\n    mouseover: 'onMouseOver',\n    mousemove: 'onMouseMove',\n    click: 'onClick',\n    dblclick: 'onDblClick',\n    mouseenter: 'onMouseEnter',\n    mouseleave: 'onMouseLeave',\n    mouseout: 'onMouseOut',\n    contextmenu: 'onContextMenu',\n    touchstart: 'onTouchStart',\n    touchend: 'onTouchEnd',\n    touchmove: 'onTouchMove',\n    touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n    movestart: 'onMoveStart',\n    move: 'onMove',\n    moveend: 'onMoveEnd',\n    dragstart: 'onDragStart',\n    drag: 'onDrag',\n    dragend: 'onDragEnd',\n    zoomstart: 'onZoomStart',\n    zoom: 'onZoom',\n    zoomend: 'onZoomEnd',\n    rotatestart: 'onRotateStart',\n    rotate: 'onRotate',\n    rotateend: 'onRotateEnd',\n    pitchstart: 'onPitchStart',\n    pitch: 'onPitch',\n    pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n    wheel: 'onWheel',\n    boxzoomstart: 'onBoxZoomStart',\n    boxzoomend: 'onBoxZoomEnd',\n    boxzoomcancel: 'onBoxZoomCancel',\n    resize: 'onResize',\n    load: 'onLoad',\n    render: 'onRender',\n    idle: 'onIdle',\n    remove: 'onRemove',\n    data: 'onData',\n    styledata: 'onStyleData',\n    sourcedata: 'onSourceData',\n    error: 'onError'\n};\nconst settingNames = [\n    'minZoom',\n    'maxZoom',\n    'minPitch',\n    'maxPitch',\n    'maxBounds',\n    'projection',\n    'renderWorldCopies'\n];\nconst handlerNames = [\n    'scrollZoom',\n    'boxZoom',\n    'dragRotate',\n    'dragPan',\n    'keyboard',\n    'doubleClickZoom',\n    'touchZoomRotate',\n    'touchPitch'\n];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n    constructor(MapClass, props, container) {\n        // mapboxgl.Map instance. Not using type here because we are accessing\n        // private members and methods\n        this._map = null;\n        // Internal states\n        this._internalUpdate = false;\n        this._inRender = false;\n        this._hoveredFeatures = null;\n        this._deferredEvents = {\n            move: false,\n            zoom: false,\n            pitch: false,\n            rotate: false\n        };\n        this._onEvent = (e) => {\n            // @ts-ignore\n            const cb = this.props[otherEvents[e.type]];\n            if (cb) {\n                cb(e);\n            }\n        };\n        this._onPointerEvent = (e) => {\n            if (e.type === 'mousemove' || e.type === 'mouseout') {\n                this._updateHover(e);\n            }\n            // @ts-ignore\n            const cb = this.props[pointerEvents[e.type]];\n            if (cb) {\n                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n                    const features = this._hoveredFeatures ||\n                        this._map.queryRenderedFeatures(e.point, {\n                            layers: this.props.interactiveLayerIds\n                        });\n                    if (!features.length) {\n                        return;\n                    }\n                    e.features = features;\n                }\n                cb(e);\n                delete e.features;\n            }\n        };\n        this._onCameraEvent = (e) => {\n            if (!this._internalUpdate) {\n                // @ts-ignore\n                const cb = this.props[cameraEvents[e.type]];\n                if (cb) {\n                    cb(e);\n                }\n            }\n            if (e.type in this._deferredEvents) {\n                this._deferredEvents[e.type] = false;\n            }\n        };\n        this._MapClass = MapClass;\n        this.props = props;\n        this._initialize(container);\n    }\n    get map() {\n        return this._map;\n    }\n    get transform() {\n        return this._renderTransform;\n    }\n    setProps(props) {\n        const oldProps = this.props;\n        this.props = props;\n        const settingsChanged = this._updateSettings(props, oldProps);\n        if (settingsChanged) {\n            this._renderTransform = this._map.transform.clone();\n        }\n        const sizeChanged = this._updateSize(props);\n        const viewStateChanged = this._updateViewState(props, true);\n        this._updateStyle(props, oldProps);\n        this._updateStyleComponents(props, oldProps);\n        this._updateHandlers(props, oldProps);\n        // If 1) view state has changed to match props and\n        //    2) the props change is not triggered by map events,\n        // it's driven by an external state change. Redraw immediately\n        if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n            this.redraw();\n        }\n    }\n    static reuse(props, container) {\n        const that = Mapbox.savedMaps.pop();\n        if (!that) {\n            return null;\n        }\n        const map = that.map;\n        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n        // intoto the new container from the props.\n        // Step1: reparenting child nodes from old container to new container\n        const oldContainer = map.getContainer();\n        container.className = oldContainer.className;\n        while (oldContainer.childNodes.length > 0) {\n            container.appendChild(oldContainer.childNodes[0]);\n        }\n        // Step2: replace the internal container with new container from the react component\n        // @ts-ignore\n        map._container = container;\n        // Step 3: apply new props\n        if (props.initialViewState) {\n            that._updateViewState(props.initialViewState, false);\n        }\n        map.resize();\n        that.setProps({ ...props, styleDiffing: false });\n        // Simulate load event\n        if (map.isStyleLoaded()) {\n            map.fire('load');\n        }\n        else {\n            map.once('styledata', () => map.fire('load'));\n        }\n        return that;\n    }\n    /* eslint-disable complexity,max-statements */\n    _initialize(container) {\n        const { props } = this;\n        const mapOptions = {\n            ...props,\n            ...props.initialViewState,\n            accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n            container,\n            style: normalizeStyle(props.mapStyle)\n        };\n        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n        Object.assign(mapOptions, {\n            center: [viewState.longitude || 0, viewState.latitude || 0],\n            zoom: viewState.zoom || 0,\n            pitch: viewState.pitch || 0,\n            bearing: viewState.bearing || 0\n        });\n        if (props.gl) {\n            // eslint-disable-next-line\n            const getContext = HTMLCanvasElement.prototype.getContext;\n            // Hijack canvas.getContext to return our own WebGLContext\n            // This will be called inside the mapboxgl.Map constructor\n            // @ts-expect-error\n            HTMLCanvasElement.prototype.getContext = () => {\n                // Unhijack immediately\n                HTMLCanvasElement.prototype.getContext = getContext;\n                return props.gl;\n            };\n        }\n        const map = new this._MapClass(mapOptions);\n        // Props that are not part of constructor options\n        if (viewState.padding) {\n            map.setPadding(viewState.padding);\n        }\n        if (props.cursor) {\n            map.getCanvas().style.cursor = props.cursor;\n        }\n        this._renderTransform = map.transform.clone();\n        // Hack\n        // Insert code into map's render cycle\n        const renderMap = map._render;\n        map._render = (arg) => {\n            this._inRender = true;\n            renderMap.call(map, arg);\n            this._inRender = false;\n        };\n        const runRenderTaskQueue = map._renderTaskQueue.run;\n        map._renderTaskQueue.run = (arg) => {\n            runRenderTaskQueue.call(map._renderTaskQueue, arg);\n            this._onBeforeRepaint();\n        };\n        map.on('render', () => this._onAfterRepaint());\n        // Insert code into map's event pipeline\n        const fireEvent = map.fire;\n        map.fire = this._fireEvent.bind(this, fireEvent);\n        // add listeners\n        map.on('resize', () => {\n            this._renderTransform.resize(map.transform.width, map.transform.height);\n        });\n        map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n        map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n        for (const eventName in pointerEvents) {\n            map.on(eventName, this._onPointerEvent);\n        }\n        for (const eventName in cameraEvents) {\n            map.on(eventName, this._onCameraEvent);\n        }\n        for (const eventName in otherEvents) {\n            map.on(eventName, this._onEvent);\n        }\n        this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n    recycle() {\n        Mapbox.savedMaps.push(this);\n    }\n    destroy() {\n        this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n    redraw() {\n        const map = this._map;\n        // map._render will throw error if style does not exist\n        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n        //   /src/ui/map.js#L1834\n        if (!this._inRender && map.style) {\n            // cancel the scheduled update\n            if (map._frame) {\n                map._frame.cancel();\n                map._frame = null;\n            }\n            // the order is important - render() may schedule another update\n            map._render();\n        }\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n    _updateSize(nextProps) {\n        // Check if size is controlled\n        const { viewState } = nextProps;\n        if (viewState) {\n            const map = this._map;\n            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n                map.resize();\n                return true;\n            }\n        }\n        return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n    _updateViewState(nextProps, triggerEvents) {\n        if (this._internalUpdate) {\n            return false;\n        }\n        const map = this._map;\n        const tr = this._renderTransform;\n        // Take a snapshot of the transform before mutation\n        const { zoom, pitch, bearing } = tr;\n        const changed = applyViewStateToTransform(tr, {\n            ...transformToViewState(map.transform),\n            ...nextProps\n        });\n        if (changed && triggerEvents) {\n            const deferredEvents = this._deferredEvents;\n            // Delay DOM control updates to the next render cycle\n            deferredEvents.move = true;\n            deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n            deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n            deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n        }\n        // Avoid manipulating the real transform when interaction/animation is ongoing\n        // as it would interfere with Mapbox's handlers\n        if (!map.isMoving()) {\n            applyViewStateToTransform(map.transform, nextProps);\n        }\n        return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateSettings(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of settingNames) {\n            if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n                changed = true;\n                map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n            }\n        }\n        return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n    _updateStyle(nextProps, currProps) {\n        if (nextProps.cursor !== currProps.cursor) {\n            this._map.getCanvas().style.cursor = nextProps.cursor;\n        }\n        if (nextProps.mapStyle !== currProps.mapStyle) {\n            const options = {\n                diff: nextProps.styleDiffing\n            };\n            if ('localIdeographFontFamily' in nextProps) {\n                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n            }\n            this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n            return true;\n        }\n        return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateStyleComponents(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        if (map.style.loaded()) {\n            if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n                changed = true;\n                map.setLight(nextProps.light);\n            }\n            if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n                changed = true;\n                map.setFog(nextProps.fog);\n            }\n            if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n                if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n                    changed = true;\n                    map.setTerrain(nextProps.terrain);\n                    // Copy changes to the transform\n                    // @ts-ignore\n                    this._renderTransform.elevation = map.transform.elevation;\n                }\n            }\n        }\n        return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n    _updateHandlers(nextProps, currProps) {\n        const map = this._map;\n        let changed = false;\n        for (const propName of handlerNames) {\n            const newValue = nextProps[propName];\n            if (!deepEqual(newValue, currProps[propName])) {\n                changed = true;\n                if (newValue) {\n                    map[propName].enable(newValue);\n                }\n                else {\n                    map[propName].disable();\n                }\n            }\n        }\n        return changed;\n    }\n    _updateHover(e) {\n        const { props } = this;\n        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n        if (shouldTrackHoveredFeatures) {\n            const eventType = e.type;\n            const wasHovering = this._hoveredFeatures?.length > 0;\n            let features;\n            if (eventType === 'mousemove') {\n                try {\n                    features = this._map.queryRenderedFeatures(e.point, {\n                        layers: props.interactiveLayerIds\n                    });\n                }\n                catch {\n                    features = [];\n                }\n            }\n            else {\n                features = [];\n            }\n            const isHovering = features.length > 0;\n            if (!isHovering && wasHovering) {\n                e.type = 'mouseleave';\n                this._onPointerEvent(e);\n            }\n            this._hoveredFeatures = features;\n            if (isHovering && !wasHovering) {\n                e.type = 'mouseenter';\n                this._onPointerEvent(e);\n            }\n            e.type = eventType;\n        }\n        else {\n            this._hoveredFeatures = null;\n        }\n    }\n    _fireEvent(baseFire, event, properties) {\n        const map = this._map;\n        const tr = map.transform;\n        const eventType = typeof event === 'string' ? event : event.type;\n        if (eventType === 'move') {\n            this._updateViewState(this.props, false);\n        }\n        if (eventType in cameraEvents) {\n            if (typeof event === 'object') {\n                event.viewState = transformToViewState(tr);\n            }\n            if (this._map.isMoving()) {\n                // Replace map.transform with ours during the callbacks\n                map.transform = this._renderTransform;\n                baseFire.call(map, event, properties);\n                map.transform = tr;\n                return map;\n            }\n        }\n        baseFire.call(map, event, properties);\n        return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n    _onBeforeRepaint() {\n        const map = this._map;\n        // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n        this._internalUpdate = true;\n        for (const eventType in this._deferredEvents) {\n            if (this._deferredEvents[eventType]) {\n                map.fire(eventType);\n            }\n        }\n        this._internalUpdate = false;\n        const tr = this._map.transform;\n        // Make sure camera matches the current props\n        this._map.transform = this._renderTransform;\n        this._onAfterRepaint = () => {\n            // Restores camera state before render/load events are fired\n            this._map.transform = tr;\n        };\n    }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n    let accessToken = null;\n    /* global location, process */\n    if (typeof location !== 'undefined') {\n        const match = /access_token=([^&\\/]*)/.exec(location.search);\n        accessToken = match && match[1];\n    }\n    // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n    try {\n        accessToken = accessToken || process.env.MapboxAccessToken;\n    }\n    catch {\n        // ignore\n    }\n    try {\n        accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n    }\n    catch {\n        // ignore\n    }\n    return accessToken;\n}\n//# sourceMappingURL=mapbox.js.map"]},"metadata":{},"sourceType":"module"}